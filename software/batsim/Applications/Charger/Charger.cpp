#include "Charger.h"
#include "gui.h"
#include "pushpull.h"

static const uint16_t imagedata[1024] = {
		0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0020,0x2965,0x528a,0x6b6d,0x7bcf,0x7bcf,0x528a,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1020,0x1840,0x0000,0x0000,0x0000,0x0000,0x0841,0x39c7,0x5acb,0x8410,0x94b2,0x94b2,0x6b4d,0x0841,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1840,0x6180,0x2880,0x0000,0x10a2,0x0841,0x0020,0x0861,0x3186,0x4228,0x632c,0x738e,0x7bcf,0x5acb,0x2104,0x0841,0x0841,0x1082,0x0000,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x1020,0x8240,0x8240,0x0800,0x0841,0x52aa,0x4208,0x31a6,0x39c7,0x4208,0x4a49,0x528a,0x6b4d,0x9cf3,0x9cf3,0x8c51,0x632c,0x5acb,0x4a49,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0820,0x7220,0xcc00,0x4940,0x0000,0x0861,0x5aeb,0x4208,0x3a27,0x4268,0x4a89,0x52ca,0x5b0b,0x6bad,0xad75,0xad95,0xad75,0x8c91,0x8410,0x52aa,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x61a0,0xcc20,0xbba0,0x2060,0x0000,0x0861,0x5aeb,0x3a26,0x4be7,0x4c28,0x4c48,0x5448,0x5c89,0x6d0c,0xae74,0xb675,0xae74,0x8d70,0x6b6c,0x52aa,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4120,0xbbe0,0xe4c0,0x92c0,0x0800,0x0000,0x0861,0x5aeb,0x3226,0x4c47,0x4487,0x4466,0x4486,0x4cc7,0x654a,0xa673,0xa693,0x9e51,0x6cea,0x31c5,0x4a69,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2080,0xab60,0xe500,0xdcc0,0x6a00,0x0000,0x0000,0x0861,0x630c,0x3226,0x4466,0x4486,0x3c85,0x3c85,0x44c5,0x5528,0x9e71,0x9e91,0x964f,0x64e8,0x2984,0x4a69,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x1020,0x82a0,0xe520,0xe520,0xd4c0,0x4120,0x0000,0x0000,0x0861,0x630c,0x3205,0x3be5,0x3405,0x3404,0x3424,0x3c44,0x4cc7,0x9631,0x9e31,0x8e0f,0x5c87,0x2984,0x528a,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x61e0,0xd4c0,0xe560,0xe560,0xc440,0x2080,0x0000,0x0000,0x0861,0x630c,0x2124,0x10c1,0x08c1,0x08a1,0x08a0,0x08a0,0x1943,0x73ce,0x73ce,0x5b2b,0x2163,0x18c3,0x528a,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x3900,0xbc20,0xed80,0xed80,0xed80,0x9b80,0x0820,0x0000,0x0000,0x0861,0x630c,0x2124,0x08c1,0x08a1,0x08a1,0x08a0,0x08a0,0x1923,0x73cd,0x73cd,0x5b2b,0x2163,0x18c3,0x52aa,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x1840,0x9b60,0xeda0,0xedc0,0xedc0,0xeda0,0x7260,0x0000,0x0000,0x0000,0x0861,0x630c,0x2a05,0x33c4,0x3404,0x3c24,0x3c65,0x4485,0x54e6,0x8e0e,0x8e2e,0x860d,0x5ca7,0x29a4,0x52aa,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0820,0x7a80,0xe580,0xedc0,0xede0,0xf600,0xe5a0,0x82e0,0x4160,0x3900,0x28c0,0x28e1,0x6b0a,0x3a25,0x3c65,0x44c5,0x44e5,0x4d26,0x4d46,0x5da7,0x968f,0x96af,0x8e8d,0x6568,0x29a4,0x52aa,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x51a0,0xccc0,0xede0,0xee00,0xf620,0xf620,0xf620,0xede0,0xe5a0,0xdd40,0xd4e0,0xc480,0xcca2,0x62a2,0x4465,0x44c5,0x4506,0x4d26,0x5566,0x65c8,0x968f,0x96cf,0x8ead,0x6d88,0x29a4,0x52aa,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x30c0,0xb400,0xedc0,0xede0,0xf620,0xf640,0xf660,0xf660,0xf640,0xf620,0xee00,0xedc0,0xeda0,0xbc64,0x3a24,0x3be5,0x3c45,0x4465,0x4485,0x4cc5,0x5527,0x8e2e,0x8e2e,0x860d,0x5cc7,0x29a4,0x52aa,0x0020,0x0000,0x0000,0x0000,
		0x1840,0x8ae0,0xdd60,0xe5a0,0xede0,0xf620,0xf660,0xf660,0xf680,0xf660,0xf640,0xf600,0xede0,0xc4a1,0x8b8a,0x2124,0x10c1,0x08c1,0x08c1,0x08a1,0x08a0,0x1922,0x5b0a,0x530a,0x4a88,0x1942,0x18c3,0x52aa,0x0020,0x0000,0x0000,0x0000,
		0x1020,0x4140,0x51a0,0x6220,0x7aa0,0x8b40,0xd540,0xfe80,0xfe80,0xf680,0xf640,0xf620,0xdd40,0x6a61,0x630c,0x2124,0x10c1,0x08c1,0x08a1,0x08a1,0x08a0,0x1922,0x5aea,0x5b0a,0x4a88,0x1922,0x18c3,0x52aa,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x1040,0xb460,0xfea0,0xfea0,0xfe80,0xf660,0xee20,0x8300,0x1881,0x630c,0x3225,0x4425,0x4465,0x4c85,0x4cc5,0x54e6,0x5d47,0x962e,0x964e,0x8e2d,0x64e7,0x29a4,0x52aa,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x20a0,0xd560,0xfea0,0xfec0,0xfea0,0xf660,0xac20,0x2080,0x0861,0x630c,0x3225,0x4cc6,0x5546,0x5d67,0x5da7,0x65c8,0x7629,0x9ed0,0xa6ef,0x9eee,0x75c8,0x29a4,0x52aa,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x4160,0xe600,0xfea0,0xfec0,0xfe80,0xd540,0x4980,0x0000,0x0861,0x630c,0x3225,0x4ce6,0x5d47,0x6588,0x65c8,0x6e09,0x7e4a,0xa6f0,0xa710,0x9eee,0x75c9,0x29a4,0x52aa,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x6240,0xf640,0xfea0,0xfea0,0xee40,0x72a0,0x0800,0x0000,0x0861,0x630c,0x3225,0x4c66,0x54e7,0x5d08,0x6548,0x6d69,0x75aa,0x9e70,0x9e6f,0x964d,0x6d08,0x29a4,0x528a,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x8b20,0xf640,0xfe80,0xf680,0x9bc0,0x1040,0x0000,0x0000,0x0861,0x630c,0x2144,0x1923,0x2164,0x29a4,0x29c5,0x31c5,0x3206,0x52ca,0x4aa9,0x3a27,0x2143,0x18c3,0x528a,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x1020,0xac00,0xf640,0xf660,0xc4c0,0x3100,0x0000,0x0000,0x0000,0x0861,0x630c,0x2945,0x2143,0x2984,0x31c5,0x31e6,0x3a06,0x3a27,0x5aea,0x52c9,0x4247,0x2163,0x18e3,0x528a,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x2080,0xcce0,0xf620,0xdd80,0x5a00,0x0000,0x0000,0x0000,0x0000,0x0841,0x630c,0x3a67,0x5ca8,0x6d09,0x754a,0x7d8b,0x7dac,0x85ec,0x9e4f,0x964e,0x8e2d,0x7509,0x31e5,0x528a,0x0020,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x4140,0xdd60,0xede0,0x7ae0,0x0820,0x0000,0x0000,0x0000,0x0000,0x0841,0x630c,0x4287,0x6d49,0x7dcb,0x860c,0x8e2d,0x966e,0x9e8e,0xa6d0,0xa6f0,0x9ece,0x85ca,0x31e5,0x528a,0x0000,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x6a20,0xe5a0,0x9b80,0x1840,0x0000,0x0000,0x0000,0x0000,0x0000,0x0841,0x630c,0x42a8,0x754a,0x7dcc,0x8e0d,0x964e,0x966f,0x9eaf,0xaed1,0xaef0,0xa6cf,0x85cb,0x3a06,0x528a,0x0000,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0820,0x9320,0xabe0,0x28c0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0841,0x630c,0x4aa8,0x6cca,0x7d4b,0x858d,0x8dce,0x960f,0x9e2f,0xa671,0xa670,0x962e,0x750a,0x3a06,0x528a,0x0000,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x28a0,0x82c0,0x3920,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0841,0x630c,0x39e7,0x3a07,0x4268,0x52c9,0x5b2b,0x636c,0x6b8c,0x73ce,0x6b6c,0x5aea,0x3a06,0x3186,0x528a,0x0000,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0800,0x30a0,0x30e0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0841,0x4a49,0x31a6,0x3186,0x39e7,0x4228,0x528a,0x5acb,0x5acb,0x5aeb,0x528a,0x4228,0x2965,0x2965,0x39c7,0x0000,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0800,0x1020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0841,0x0020,0x0020,0x0020,0x0841,0x0841,0x0841,0x0861,0x0841,0x0841,0x0020,0x0020,0x0020,0x0020,0x0000,0x0000,0x0000,0x0000,
		0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
};

static Image_t icon = { .width = 32, .height = 32, .data = imagedata };

/* Forward declaration of actual app task */
static void Charger(void *unused);

/* Creates the app task, called from desktop when user start the app */
static void Charger_Start(){
	xTaskCreate(Charger, "Charger", 300, NULL, 3, NULL);
}

/* Register this app */
void Charger_Init() {
	App_Register("Charger", Charger_Start, icon);
}

const char modeNames[2][12] = {"Charging", "Discharging"};
const char *modes[3] = { modeNames[0], modeNames[1], NULL };

#define MODE_CHARGING			0
#define MODE_DISCHARGING		1

const char batteryNames[3][5] = {"PB", "LiPo", "LiIo"};
const char *batteries[4] = { batteryNames[0], batteryNames[1], batteryNames[2], NULL };

#define BATTERY_PB				0
#define BATTERY_LIPO			1
#define BATTERY_LIIO			2
#define BATTERY_NUM				3

const uint32_t maxCellVoltage[BATTERY_NUM] = {
		2300000, /* PB */
		4200000, /* LiPo */
		4200000, /* LiIo */
};
const uint32_t minCellVoltage[BATTERY_NUM] = {
		1750000, /* PB */
		3300000, /* LiPo */
		2500000, /* LiIo */
};

const int32_t minChargeCurrent = 20000;

/* main app widgets */
static itemChooser_t *iMode;
static itemChooser_t *iBattery;
static checkbox_t *cAuto;
static entry_t *eCells;
static button_t *bStart;

/* Charge window widgets */
static button_t *bStop;
static window_t *chargeWindow;
static sevensegment_t *sVol;
static sevensegment_t *sCur;
static entry_t *eEnergy;
static entry_t *eTime;

static uint8_t active = 0;
static uint32_t activeSince, activeFor, lastUpdate;
static uint8_t mode = 0, battery = 0;
static int32_t cells = 1, minCells = 1, maxCells = 8;
static uint32_t voltageLimit = 2300000;
static int32_t current = 500000;
static uint8_t autoEndVol = 1;
static int32_t transferredEnergy;
static int64_t residualEnergy;
static int32_t batVoltage, batCurrent;

#define MODE_CHANGED		0x01
#define TYPE_CHANGED		0x02
#define AUTO_CHANGED		0x04
#define CELLS_CHANGED		0x08
#define START_CHARGING		0x10
#define STOP_CHARGING		0x20
static uint8_t userInputFlags = 0;

static TaskHandle_t handle;

static void UserInput(widget_t* w) {
	if (w == (widget_t*) iMode) {
		userInputFlags |= MODE_CHANGED;
	} else if (w == (widget_t*) iBattery) {
		userInputFlags |= TYPE_CHANGED;
	} else if (w == (widget_t*) eCells) {
		userInputFlags |= CELLS_CHANGED;
	} else if (w == (widget_t*) cAuto) {
		userInputFlags |= AUTO_CHANGED;
	} else if (w == (widget_t*) bStart) {
		userInputFlags |= START_CHARGING;
	} else if (w == (widget_t*) bStop) {
		userInputFlags |= STOP_CHARGING;
	}
	xTaskNotify(handle, SIGNAL_WAKEUP, eSetBits);
}

static void StartCharging(void) {
	/* Check battery voltage */
	if (mode == MODE_CHARGING) {
		/* charging */
		if (pushpull_GetBatteryVoltage() > voltageLimit) {
			dialog_MessageBox("ERROR", Font_Big,
					"Battery already\nabove maximum\nvoltage", MSG_OK, NULL, 1);
			return;
		}
		if (pushpull_GetBatteryVoltage()
				< cells * minCellVoltage[battery] / 2) {
			dialog_MessageBox("ERROR", Font_Big,
					"No battery or\ndeeply discharged", MSG_OK, NULL, 1);
			return;
		}
	} else {
		/* discharging */
		if (pushpull_GetBatteryVoltage() < voltageLimit) {
			dialog_MessageBox("ERROR", Font_Big,
					"No battery or\nalready discharged", MSG_OK, NULL, 1);
			return;
		}
		/* charging */
		if (pushpull_GetBatteryVoltage()
				> cells * (maxCellVoltage[battery] + 200000)) {
			dialog_MessageBox("ERROR", Font_Big,
					"Battery voltage too\nhigh. Check settings", MSG_OK, NULL, 1);
			return;
		}
	}
	/* Battery seems to be okay, start charging/discharging */

	/* Create GUI elements */
	sVol = sevensegment_new(&batVoltage, 20, 7, 5, 2, COLOR_DARKGREEN);
	sCur = sevensegment_new(&batCurrent, 20, 7, 5, 3, COLOR_RED);
	batVoltage = 0;
	batCurrent = 0;

	label_t *lV = label_newWithText("V", Font_Big);
	lV->color = COLOR_DARKGREEN;
	label_t *lA = label_newWithText("A", Font_Big);
	lA->color = COLOR_RED;

	/* Keep track of transferred energy */
	label_t *lEnergy = label_newWithText("Energy:", Font_Big);
	eEnergy = entry_new(&transferredEnergy, NULL, NULL, Font_Big, 8, &Unit_Energy);
	widget_SetSelectable((widget_t*) eEnergy, 0);
	transferredEnergy = 0;
	residualEnergy = 0;

	/* Keep track of time */
	label_t *lTime = label_newWithText("Time:", Font_Big);
	eTime = entry_new((int32_t*) &activeFor, NULL, NULL, Font_Big, 8,
			&Unit_Time);
	widget_SetSelectable((widget_t*) eTime, 0);
	activeFor = 0;

	bStop = button_new("Abort", Font_Big, 0, UserInput);

	char title[15];
	if(mode == MODE_CHARGING) {
		strncpy(title, "CHARGING...", sizeof(title));
	} else {
		strncpy(title, "DISCHARGING...", sizeof(title));
	}
	chargeWindow = window_new(title, Font_Big, COORDS(195, 200));
	container_t *c = container_new(window_GetAvailableArea(chargeWindow));

	/* Attach elements to container */
	container_attach(c, (widget_t*) sVol, COORDS(3, 3));
	container_attach(c, (widget_t*) lV, COORDS(170, 6));

	container_attach(c, (widget_t*) sCur, COORDS(3, 53));
	container_attach(c, (widget_t*) lA, COORDS(170, 56));

	container_attach(c, (widget_t*) lEnergy, COORDS(0, 106));
	container_attach(c, (widget_t*) eEnergy, COORDS(85, 106));

	container_attach(c, (widget_t*) lTime, COORDS(0, 128));
	container_attach(c, (widget_t*) eTime, COORDS(85, 128));

	container_attach(c, (widget_t*) bStop,
			COORDS((c->base.size.x - bStop->base.size.x) / 2, 150));

	window_SetMainWidget(chargeWindow, (widget_t*) c);

	/* Indicate beginning of charging process */
	active = 1;
	activeSince = lastUpdate = xTaskGetTickCount();

	/* Set output */
	pushpull_SetDriveCurrent(200);
	if(mode==MODE_CHARGING) {
		pushpull_SetVoltage(voltageLimit);
		pushpull_SetSourceCurrent(current);
		/* allow some sink current in case of offset */
		pushpull_SetSinkCurrent(5000);
	} else {
		/* Set voltage all the way to zero, current is limited */
		pushpull_SetVoltage(0);
		/* allow some source current in case of offset */
		pushpull_SetSourceCurrent(5000);
		pushpull_SetSinkCurrent(current);
	}
	pushpull_SetEnabled(1);
}

static void StopCharging(void) {
	/* Disable output */
	pushpull_SetDefault();

	if(chargeWindow) {
		window_destroy(chargeWindow);
	}

	active = 0;
}

static void Charge(void) {
	/* Update status */
	batVoltage = pushpull_GetBatteryVoltage()/10000;
	batCurrent = pushpull_GetCurrent()/1000;
	activeFor = xTaskGetTickCount() - activeSince;
	/* Calculate transferred energy */
	int64_t power = (int64_t) pushpull_GetBatteryVoltage()
			* pushpull_GetCurrent() / 1000000UL;
	uint32_t timediff = xTaskGetTickCount() - lastUpdate;
	lastUpdate += timediff;
	residualEnergy += power * timediff;
	int32_t uWh = residualEnergy / 3600000UL;
	if (uWh) {
		transferredEnergy += uWh;
		residualEnergy -= (int64_t) uWh * 3600000UL;
	}
	/* Update widgets */
	widget_RequestRedraw((widget_t*) sVol);
	widget_RequestRedraw((widget_t*) sCur);
	widget_RequestRedraw((widget_t*) eTime);
	widget_RequestRedraw((widget_t*) eEnergy);

	/* Monitor end of charge */
	if(activeFor > 1000) {
		/* Charging started a second ago */
		/* if current or voltage falls below threshold, stop charging */
		if ((pushpull_GetCurrent() < current / 20 && mode == MODE_CHARGING)
				|| (pushpull_GetBatteryVoltage() < voltageLimit
						&& mode == MODE_DISCHARGING)) {
			/* Charging: current has become quite small, stop charging */
			/* Discharging: voltage has passed the voltage limit, stop charging */
			StopCharging();
			/* Display charging result */
			char energy[9];
			common_StringFromValue(energy, 8, transferredEnergy, &Unit_Energy);
			char time[8];
			common_StringFromValue(time, 7, activeFor, &Unit_Time);
			char msg[50];
			snprintf(msg, sizeof(msg), "Transferred %s\nin %s", energy, time);
			dialog_MessageBox("DONE", Font_Big, msg, MSG_OK, NULL, 1);

		}
	}
}

static void Charger(void *unused) {
	handle = xTaskGetCurrentTaskHandle();
	/* Create GUI elements */
	container_t *c= container_new(COORDS(280, 240));
	c->base.position.x = 40;

	label_t *lMode = label_newWithText("Mode:", Font_Big);
	label_t *lType = label_newWithText("Type:", Font_Big);
	label_t *lCells = label_newWithText("Cells:", Font_Big);
	label_t *lCurrent = label_newWithText("Max I:", Font_Big);
	label_t *lAuto = label_newWithText("Auto:", Font_Big);
	label_t *lEndVol = label_newWithText("Limit:", Font_Big);

	/* User input fields */
	iMode = itemChooser_new(modes, &mode, Font_Big, 2, 0);
	iBattery = itemChooser_new(batteries, &battery, Font_Big, 3, 0);
	iMode->changeCallback = UserInput;
	iBattery->changeCallback = UserInput;

	eCells = entry_new(&cells, &maxCells, &minCells, Font_Big, 2, &Unit_None);
	eCells->changeCallback = UserInput;
	entry_t *eCurrent = entry_new(&current, &Limits.maxCurrent,
			&minChargeCurrent, Font_Big, 6, &Unit_Current);

	cAuto = checkbox_new(&autoEndVol, UserInput);

	entry_t *eEndVol = entry_new((int32_t*) &voltageLimit, &Limits.maxVoltage,
			&null, Font_Big, 6, &Unit_Voltage);
	widget_SetSelectable((widget_t*) eEndVol, !autoEndVol);

	bStart = button_new("START", Font_Big, 100, UserInput);

	/* Attach GUI elements to main container */
	container_attach(c, (widget_t*) lMode, COORDS(5, 5));
	container_attach(c, (widget_t*) iMode, COORDS(5, 25));

	container_attach(c, (widget_t*) lType, COORDS(180, 5));
	container_attach(c, (widget_t*) iBattery, COORDS(180, 25));

	container_attach(c, (widget_t*) lCells, COORDS(5, 102));
	container_attach(c, (widget_t*) eCells, COORDS(80, 100));

	container_attach(c, (widget_t*) lCurrent, COORDS(125, 102));
	container_attach(c, (widget_t*) eCurrent, COORDS(200, 100));

	container_attach(c, (widget_t*) lEndVol, COORDS(5, 138));
	container_attach(c, (widget_t*) eEndVol, COORDS(80, 136));

	container_attach(c, (widget_t*) lAuto, COORDS(175, 138));
	container_attach(c, (widget_t*) cAuto, COORDS(235, 130));

	container_attach(c, (widget_t*) bStart, COORDS(90, 210));

	/* Notify desktop of started app */
	desktop_AppStarted(Charger_Start, (widget_t*) c);

	active = 0;
	/* Initialize pushpull stage */
	pushpull_AcquireControl();
	pushpull_SetAveraging(300);
	pushpull_SetDriveCurrent(200);
	pushpull_SetEnabled(0);
	pushpull_SetInternalResistance(0);

	while(1) {
		uint32_t signal;
		if (App_Handler(&signal, 300)) {
			/* Handle app signals */
			if(signal & SIGNAL_WAKEUP) {
				/* Check user input */
				if (userInputFlags & (MODE_CHANGED | CELLS_CHANGED|TYPE_CHANGED)) {
					/* update max. number of cells */
					maxCells = MAX_VOLTAGE / maxCellVoltage[battery];
					widget_RequestRedraw((widget_t*) eCells);
					/* enable auto voltage limit */
					autoEndVol = 1;
					widget_SetSelectable((widget_t*) eEndVol, !autoEndVol);
					widget_RequestRedrawFull((widget_t*) cAuto);
					/* clear flag */
					userInputFlags &= ~(MODE_CHANGED | CELLS_CHANGED|TYPE_CHANGED);
				}

				if (userInputFlags & AUTO_CHANGED) {
					widget_SetSelectable((widget_t*) eEndVol, !autoEndVol);
					/* clear flag */
					userInputFlags &= ~MODE_CHANGED;
				}

				if (autoEndVol) {
					/* update voltage limit */
					if (mode == MODE_CHARGING) {
						/* charging */
						voltageLimit = maxCellVoltage[battery] * cells;
					} else {
						/* discharging */
						voltageLimit = minCellVoltage[battery] * cells;
					}
					widget_RequestRedraw((widget_t*) eEndVol);
				}

				if(userInputFlags & START_CHARGING) {
					StartCharging();
					/* clear flag */
					userInputFlags &= ~START_CHARGING;
				}

				if(userInputFlags & STOP_CHARGING) {
					StopCharging();
					/* clear flag */
					userInputFlags &= ~STOP_CHARGING;
				}
			}
		}

		if(active) {
			Charge();
		}
	}
}




